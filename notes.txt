Pseudorandom Orthogonal Transformations:

P:  is a linear operator that takes a vector and permutes its coordinates
        Find out hopw you use the rng_engine
        Try sequentially
        Try parallel with split

Q:  is a linear operator that takes a vector and rotates the coordinates
        When applying eq 7 do it sequentially with a loop (maybe nontrivial?)
        Also do the rotations inplace instead of using map
        Normalize the rng_engines output numbers: (rand.ToFloat/(u32.highest number).ToFloat) Then scale with 2pi

Fd: a linear operator that takes a vector uses a one to one operator to 
        transform the vector from R^d to C^(d/2) multiplies this with a 
        Fourier transform matrix and then converts the vector back to R^d 
                Play around with complex numbers
                Create a matrix-vector multiplcation that works with complex numbers

Theta: takes a vector and runs it through P and Q a 'm2' times then through
        Fd and then again through P and Q m1 times
                Theta is a function that should permute all points similarly for an iteration of T
            loop acc = Fd_m2_PQ for i < m1 -1 do
                    let pointP = calculate_Pj acc permutations[i+m2]
                    let ind_1 = m2 * i * (d-1)
                    let ind_2 = m2 * (i+1)*(d-1) 
                    in calculate_Qj pointP random_numbers[ind_1:ind_2:1]

let Fd_final [d] (F : []f32) (point : [d]f32) (F2 : [d]f32) : [d]f32 =
    if length F != length point then 
        map (\i -> if i == d-1 then point[d-1]
                                else F[i]) (iota d)
    else if length F == d then F2
    else point


    


    
    --let Z = iota d2
    --for (i32 i = 0; i < (d2 * 2); i+=2) do
    --    Z[i] = complex(Vector[i], Vector[i+1])