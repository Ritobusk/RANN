Pseudorandom Orthogonal Transformations:

P:  is a linear operator that takes a vector and permutes its coordinates
        Find out how you use the rng_engine
        Try sequentially
        Try parallel with split

Q:  is a linear operator that takes a vector and rotates the coordinates
        When applying eq 7 do it sequentially with a loop (maybe nontrivial?)
        Also do the rotations inplace instead of using map
        Normalize the rng_engines output numbers: (rand.ToFloat/(u32.highest number).ToFloat) Then scale with 2pi

Fd: a linear operator that takes a vector uses a one to one operator to 
        transform the vector from R^d to C^(d/2) multiplies this with a 
        Fourier transform matrix and then converts the vector back to R^d 
                Play around with complex numbers
                Create a matrix-vector multiplication that works with complex numbers

Theta: takes a vector and runs it through P and Q a 'm2' times then through
        Fd and then again through P and Q m1 times
                Theta is a function that should permute all points similarly for an iteration of T


    


CENTER OF MASS OF THE COLLECTION?:
        https://www.khanacademy.org/science/physics/linear-momentum/center-of-mass/v/center-of-mass-equation
        Just add all the points and then divide the resulting vector with the number of points???
        sum = reduce (\acc point -> map2 (+) acc point ) acc points
        shiftedPoints = map (\i -> i / n) sum


How to calculate L in eq 18:
        floor of log2(N/k)

Constructing tree:
        Pad the points such that each leaf has the same number of elements. 
        Since I want the leaves to have a fixed size of a power of 2 I have 
                to pad accordingly.

        Stopping condition is when leaves have the specified size (defined points per leaf).
                Find median of first coordinate/dim with rank-k search
                Split at the median (with partition)


Find initial leaf for each point
        Save the path taken with a word of bits e.g. [1, 0, 0, 1]. This represents [+, -, -, +]
                in the paper notation.


Finding V_i...
        You have 2^L leaves with close to k points.
        for each point
                B_siqma: you have the box they belong to and its array of +,- symbols.
                        found by traversing tree
                traverse the tree and return the L leaves that have an array (+,-) that 
                        differs at only 1 index from B_sigma's array.  

        output: (close to k points) * (L + 1) candidates.

Find actual K-nn of V_i
        Look at fig 3 in propagation assisted k-d trees 



Medians: How should you handle when a column has a lot of values equal to the median? 
        A bug that could be solved when algorithm is almost finished.
        
Partition "3" from pmph used instead of native partition. 


IMPORTANT: The data that is used to build the tree is seperate from the queries you want to search!!
                That is why you need a findNaturalLeaf function for the queries! 
           I should create a new treeBuildTraverse that has this in mind!!
           This makes it so it makes sense to sort the queries in relation to their leaf number!

I should also modify the med_dims so that it goes like this e.g. [0,1,2,0,1] if d = 3 and height = 5
instead of [0,1,2,2,2] like it is now.


[[[[6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32]], [[2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32]]], 
[[[4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32]], [[3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32]]], 
[[[3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32]], [[4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32]]], 
[[[2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32]], [[6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32]]]]

[[[6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32], [2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32]],
[[4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32], [3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32]],
[[3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32], [4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32]],
[[2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32], [6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32]]]


[[3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32], [2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32], [6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32], [4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32]]
[5i32, 6i32, 0i32, 7i32, 2i32, 4i32, 1i32, 3i32]
[0i32, 1i32, 1i32]
[4.000000f32, 3.000000f32, 2.000000f32]
[0i32, 0i32, 1i32, 1i32, 2i32, 2i32, 3i32, 3i32]
[[0i32, 0i32], [0i32, 0i32], [0i32, 1i32], [0i32, 1i32], [1i32, 0i32], [1i32, 0i32], [1i32, 1i32], [1i32, 1i32]]
[[2i32, 1i32], [3i32, 0i32], [0i32, 3i32], [1i32, 2i32]]
[[[6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32], [2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32]], [[4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32], [3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32]], [[3.000000f32, 1.000000f32], [1.000000f32, 2.000000f32], [4.000000f32, 2.000000f32], [8.000000f32, 2.000000f32]], [[2.000000f32, 3.000000f32], [1.000000f32, 5.000000f32], [6.000000f32, 1.000000f32], [9.000000f32, 1.900000f32]]]


[[2.0f32, 3.0f32],[4.0f32, 2.0f32],[6.0f32, 1.0f32],[8.0f32, 2.0f32],[9.0f32, 1.9f32]
,[3.0f32, 1.0f32] ,[1.0f32, 2.0f32],[1.0f32, 5.0f32]]


[[0i32, 2i32], [0i32, 7i32], [6i32, 5i32], [6i32, 1i32], [1i32, 3i32], 
[3i32, 1i32], [0i32, 2i32], [4i32, 2i32]]

[[2.236068f32, 3.000000f32], [1.414214f32, 3.000000f32], [1.414214f32, 2.236068f32], 
[3.000000f32, 4.242640f32], [2.236068f32, 2.236068f32], [1.004988f32, 5.001000f32], 
[2.236068f32, 2.236068f32], [1.004988f32, 2.236068f32]]